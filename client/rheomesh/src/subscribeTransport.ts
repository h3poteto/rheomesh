import { EventEmitter } from "events";
import * as sdpTransform from "sdp-transform";
import { DataSubscriber, Subscriber } from "./subscriber";

export class SubscribeTransport extends EventEmitter {
  private _peerConnection: RTCPeerConnection;
  private _queue: Array<RTCIceCandidateInit>;
  private _track: { [publisherId: string]: MediaStreamTrack };
  private _channel: { [publisherId: string]: RTCDataChannel };
  private _signalingLock: boolean;
  private _sdp: RTCSessionDescriptionInit | null;

  constructor(config: RTCConfiguration) {
    super();
    const peer = new RTCPeerConnection(config);

    this._peerConnection = peer;
    this._queue = [];
    this._track = {};
    this._channel = {};
    this._signalingLock = false;
    this._sdp = null;

    this._peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        this.emit("icecandidate", event.candidate);
      }
    };

    this._peerConnection.ontrack = (event) => {
      console.debug("ontrack: ", event);
      const track = event.track;

      // In Chrome, track.id is always the same as track id in msid in SDP.
      // However, in Firefox, track.id is generated by the browser. As a result, the track.id is not the same as the track id in msid in SDP.
      // We want to confirm that which track is received.
      // So we need to parse the SDP and find the track id in msid.
      if (!event.transceiver.mid) {
        console.error("No mid found");
        return;
      }
      const mid = event.transceiver.mid;

      if (!this._sdp || !this._sdp.sdp) {
        console.error("No SDP found");
        return;
      }
      const sdp = sdpTransform.parse(this._sdp.sdp);
      const media = sdp.media.find((m) => parseInt(m.mid!) === parseInt(mid));
      if (!media) {
        console.error("No media found");
        return;
      }
      if (!media.msid) {
        console.error("No msid found");
        return;
      }
      const msid = media.msid;
      const msidParts = msid.split(" ");
      if (msidParts.length < 2) {
        console.error("Can't parse msid");
        return;
      }
      const trackId = msidParts[1];

      this._track[trackId] = track;
    };

    this._peerConnection.ondatachannel = (event) => {
      console.debug("ondatachannel: ", event);
      if (event.channel.id) {
        this._channel[event.channel.label] = event.channel;
      }
    };

    this._peerConnection.onsignalingstatechange = (event) => {
      console.debug(
        "onsignalingstatechange: ",
        (event.target as RTCPeerConnection).signalingState,
      );
      if ((event.target as RTCPeerConnection).signalingState === "stable") {
        this._signalingLock = false;
      }
    };
  }

  public async setOffer(
    sdp: RTCSessionDescriptionInit,
  ): Promise<RTCSessionDescriptionInit> {
    while (this._signalingLock) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    this._sdp = sdp;
    this._signalingLock = true;
    await this._peerConnection.setRemoteDescription(sdp);
    const answer = await this._peerConnection.createAnswer();
    await this._peerConnection.setLocalDescription(answer);

    if (this._queue.length > 0 && this._peerConnection.remoteDescription) {
      const candidate = this._queue.shift();
      if (candidate) {
        await this.addIceCandidate(candidate);
      }
    }

    return answer;
  }

  public async addIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {
    if (this._peerConnection.remoteDescription) {
      await this._peerConnection.addIceCandidate(
        new RTCIceCandidate(candidate),
      );
    } else {
      this._queue.push(candidate);
    }
  }

  public async subscribe(publisherId: string): Promise<Subscriber> {
    return new Promise(async (resolve, reject) => {
      for (let i = 0; i < 10; i++) {
        if (this._track[publisherId]) {
          const track = this._track[publisherId];
          const subscriber: Subscriber = {
            publisherId: publisherId,
            track: track,
          };
          return resolve(subscriber);
        }
        await sleep(500);
      }
      reject("Publisher was not found");
    });
  }

  public async subscribeData(publisherId: string): Promise<DataSubscriber> {
    return new Promise(async (resolve, reject) => {
      for (let i = 0; i < 10; i++) {
        if (this._channel[publisherId]) {
          const subscriber: DataSubscriber = {
            publisherId: publisherId,
            channel: this._channel[publisherId],
          };
          return resolve(subscriber);
        }
        await sleep(500);
      }
      reject("Subscriber was not found");
    });
  }

  public close() {
    this._peerConnection.close();
  }
}

function sleep(milliseconds: number) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
